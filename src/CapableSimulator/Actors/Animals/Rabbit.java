package CapableSimulator.Actors.Animals;

import CapableSimulator.Actors.Plants.Grass;
import CapableSimulator.Actors.Shelter.AnimalShelter;
import CapableSimulator.Actors.Shelter.Burrow;

import CapableSimulator.Utils.CapableEnums;
import CapableSimulator.Utils.PathFinder;
import CapableSimulator.Utils.SpawningAgent;
import CapableSimulator.Utils.TileFinder;
import itumulator.executable.DisplayInformation;
import itumulator.world.Location;
import itumulator.world.World;

import java.awt.*;
import java.util.*;
import java.util.List;

public class Rabbit extends Animal {

    /* ----- ----- ----- Burrow variables ----- ----- ----- */

    /** The reference to the rabbits burrow */
    private Burrow burrow;

    /** Defines the map wherein all the display information's are declared. The key is generated by the getDisplayInformationsKey() method */
    protected static final Map<String, DisplayInformation> displayInformations = new HashMap<>();
    static {
        displayInformations.put("Small-Normal-Awake", new DisplayInformation(Color.red, "rabbit-small"));                   // The display information of a small awake normal rabbit
        displayInformations.put("Big-Normal-Awake", new DisplayInformation(Color.red, "rabbit"));                           // The display information of a big awake normal rabbit

        displayInformations.put("Small-Normal-Sleeping", new DisplayInformation(Color.red, "rabbit-small-sleeping"));       // The display information of a small sleeping normal rabbit
        displayInformations.put("Big-Normal-Sleeping", new DisplayInformation(Color.red, "rabbit-sleeping"));               // The display information of a big sleeping normal rabbit

        displayInformations.put("Small-Fungi-Awake", new DisplayInformation(Color.red, "rabbit-fungi-small"));              // The display information of a small awake fungus rabbit
        displayInformations.put("Big-Fungi-Awake", new DisplayInformation(Color.red, "rabbit-fungi"));                      // The display information of a big awake fungus rabbit

        displayInformations.put("Small-Fungi-Sleeping", new DisplayInformation(Color.red, "rabbit-fungi-small-sleeping"));  // The display information of a small sleeping fungus rabbit
        displayInformations.put("Big-Fungi-Sleeping", new DisplayInformation(Color.red, "rabbit-fungi-sleeping"));          // The display information of a big sleeping fungus rabbit
    }


    /* ----- ----- ----- Constructors ----- ----- ----- */

    /** The default constructor for the rabbit class.
     *  This is the constructor to use when making the simulation.
     *  @param world The world wherein the actor exists.
     */
    public Rabbit(World world) {
        super("rabbit", world, 15, 0, 25);
        burrow = null;
    }

    /** A constructor where the rabbits starting energy can be defined, mostly for testing purposes.
     * @param world The world wherein the actor exists.
     * @param energy The starting energy of the animal
     */
    public Rabbit(World world, int energy) {
        super("rabbit", world, energy, 0, 25);
        burrow = null;
    }

    /** A constructor where the age required before mating can occur and how long before mating can occur again can be defined.
     * @param world The world wherein the actor exists.
     * @param age The animals starting age.
     * @param MATING_AGE The required age for mating.
     * @param MATING_COOLDOWN_DURATION The required time (simulation steps) before the animal can reproduce again.
     */
    public Rabbit(World world, int age, int MATING_AGE, int MATING_COOLDOWN_DURATION) {
        super("rabbit", world, 15, 25, age,  MATING_AGE, MATING_COOLDOWN_DURATION);
        burrow = null;
    }

    /* ----- ----- ----- Behavior ----- ----- ----- */

    /** Implementation of act() method from the Actor interface.
     *  Executes once per simulation step.
     *  Most of the behavior occurs within this method.
     * */
    @Override
    public void act(World world) {
        super.act(world);
        if (isDead())
            return;

        if(isInfected()) {

        }
        else if (world.isDay()) {
            if(!isOnMap()) {
                exitBurrow();
            }
            else if ( !(findMate(1) || lookForFood(1))) {
                move();
            }
        }
        else {
            if(isOnMap()) {
                if ( !(tryEnterBurrow() || lookForFood(1)) )
                    move();
            }
        }
    }

    /** Tries to find a mate to reproduce
     *  If more than one possible mate is found, then a random one is chosen.
     *  If the chosen mate is eligible to reproduce, then a offspring is created.
     *  The offspring is inserted into the world at a free surrounding tile, around the instigating rabbit
     *  If no free tile is found the offspring dies, but the mating is still counted as a success. TODO
     *
     * @param radius Is the radius of the area it tries to find a mate within.
     * @return Returns true if it successfully reproduced, otherwise returns false.
     */
    public boolean findMate(int radius) {
        // If Rabbit can't reproduce, the do nothing
        if (!canMate())
            return false;

        // Findes rabbits on surrounding tiles
        List<Rabbit> possibleMates = new ArrayList<>();
        for (Location l : world.getSurroundingTiles(getLocation(), radius)) {
            if (world.getTile(l) instanceof Rabbit rabbit)
                possibleMates.add(rabbit);
        }
        if (possibleMates.isEmpty()) return false;

        // Select a mate
        Rabbit mate;
        if (possibleMates.size() == 1) {
            mate = possibleMates.get(0);
        }
        else {
            mate =  possibleMates.get(new Random().nextInt(possibleMates.size()));
        }

        // If mate can't mate, the do nothing
        if (!mate.canMate()) return false;

        reproduce(mate);
        return true;
    }

    /**
     * @param mate Reference to the other rabbit it reproduces with.
     * @throws NullPointerException Throws exception if mate is null.
     */
    protected void reproduce(Rabbit mate) {
        if (mate == null)
            throw new NullPointerException("Rabbit mate is null");

        // If the distance between this rabbit and the mate is over 1 tile
        if (PathFinder.distance(getLocation(), mate.getLocation()) > 1) {
            Location moveTo = PathFinder.getClosestTile(world, getLocation(), mate.getLocation());
            world.move(this,  moveTo);
        }

        // Findes empty location around this rabbit
        Location offspringLocation = TileFinder.getEmptyTileAroundActor(world,this, true);
        if (offspringLocation == null) return;

        // makes new rabbit
        Rabbit offspring = new Rabbit(world);

        // Spawn offspring at location
        SpawningAgent.spawnActorAtLocation(world, offspring,  offspringLocation);

        // Updates the relevant mating information.
        animalJustReproduce();
        mate.animalJustReproduce();
    }

    /* ----- ----- ----- ----- Burrow ----- ----- ----- ----- ----- */

    /**
     * @return Returns true if it either entered a burrow or moved closer to a burrow. if no burrow was successfully created or located or it didn't move closer returns false.
     */
    private boolean tryEnterBurrow() {
        if (!hasShelter()) {
            // Looks for an existing burrow around itself to join.
            if (lookForBurrow()) {
                // if one is found, then it goes into it and returns true.
                goIntoBurrow();
                return true;
            }
            // If no existing burrow was found it tries to dig one.
            else if (digBurrow()) {
                // if it successfully dug a burrow, it then enters it and returns true.
                goIntoBurrow();
                return true;
            }
            else {
                // returns false if it wasn't possible to join or make a burrow
                return false;
            }
        }

        if (moveNextToTarget(burrow.getLocation()))
            goIntoBurrow();
        return true;
    }

    /** Handels the digging of a burrow, and connecting the rabbit to the burrow.
     * @return Returns true if a burrow was successfully made, ortherwise returns false.
     */
    public boolean digBurrow() {
        Object standingOn = world.getNonBlocking(getLocation());

        if (!prepareTileForBurrow(standingOn))
             return false;

        burrow = new Burrow(world);
        burrow.addBurrowInhabitant(this);

        SpawningAgent.spawnActorAtLocation(world, burrow, getLocation());   // spawns the burrow on the map
        burrow.setShelterLocation();
        return true;
    }

    /**
     * @param standingOn The object (object on tile) the rabbit is standing on.
     * @return Returns true if it is possible to make a burrow at the location of standigOn. Otherwise returns false.
     */
    private boolean prepareTileForBurrow(Object standingOn) {
        if (standingOn == null)
            return true;
        else if (standingOn instanceof Grass grass) {
            world.delete(grass);
            return true;
        }
        else
            return false;
    }

    /**
     * @return Returns true if the rabbit successfully found a burrow nearby. Otherwise, returns false.
     */
    private boolean lookForBurrow() {
        for (Location l : world.getSurroundingTiles(getLocation())) {
            if (world.getNonBlocking(l) instanceof Burrow burrow) {
                setBurrow(burrow);
                break;
            }
        }
        return hasShelter();
    }

    /** Handels entering the burrow */
    void goIntoBurrow() {
        updateOnMap(getLocation(), false);
        burrow.animalEnteredShelter(this);
    }

    /** Handles exiting the burrow */
    void exitBurrow() {
        Location exitLocation = PathFinder.getEmptyTileAroundLocation(world, burrow.getLocation(), 1);
        if (exitLocation == null)
            return;
        updateOnMap(exitLocation, true);
        burrow.animalLeftShelter(this);
    }

    /* ----- ----- ----- ----- Events ----- ----- ----- ----- */

    /** The implementation of the animal method onDay()
     *  Handles the events linked to day break i.e.
     *  Enabling mating again, and the rabbit appearing on the map again.
     * */
    @Override
    public void onDawn() {
        setAnimalState(CapableEnums.AnimalState.AWAKE);

        if(burrow == null) {
            System.out.println("Burrow is null");
            return;
        }

        if (!isOnMap())
            exitBurrow();
    }

    /** The implementation of the animal method onNight()
     *  Handles the events linked to nightfall i.e.
     *  The rabbit going into it's burrow if it has one, otherwise it tries to find a nearby burrow.
     *  If no nearby burrow is found, then it tries to dig one.
     * */
    @Override
    public void onNightFall() {
        setAnimalState(CapableEnums.AnimalState.SLEEPING);
        if (isOnMap())
            tryEnterBurrow();
    }

    /** The implementation of the animal method almostNight()
     *  Handles the events linked to it almost being night i.e.
     *  Making the rabbits go towards their burrow if they have one.
     *  Disabling mating until daybreak.
     * */
    @Override
    public void onDusk() {
        if(burrow == null) return;  // If rabbit doesn't have a burrow, then do nothing

        Location closestTile = PathFinder.getClosestTile(world, getLocation(), world.getLocation(burrow));
        if (closestTile == null) {
            System.out.println("Rabbit could not find a free tile around it's burrow.");    // error message if no empty tile was found around its burrow
            //TODO kill rabbit if no tile was found, burrow might be full
            return;
        }
        moveTowards(closestTile);
    }

    /* ----- ----- ----- ----- Getters ----- ----- ----- ----- ----- */

    /** Returns the rabbits burrow reference
     * @return Returns a reference to the burrow.
     */
    public Burrow getBurrow() { return burrow; }

    /**
     * @return Returns true if the rabbit has a burrow, otherwise returns false.
     */
    public boolean hasShelter() { return burrow != null; }

    @Override
    public DisplayInformation getInformation() {
        return displayInformations.get(getDisplayInformationsKey());
    }

    /* ----- ----- ----- ----- Setters ----- ----- ----- ----- ----- */

    /** Set's the reference variable burrow.
     * @param burrow The reference to the new burrow
     */
    private void setBurrow(Burrow burrow) {
        this.burrow = burrow;
    }

}
