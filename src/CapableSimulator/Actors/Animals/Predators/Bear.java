package CapableSimulator.Actors.Animals.Predators;

import CapableSimulator.Actors.Animals.Rabbit;
import CapableSimulator.CapableWorld;
import CapableSimulator.Utils.CapableEnums;
import CapableSimulator.Utils.PathFinder;
import CapableSimulator.Utils.SpawningAgent;
import CapableSimulator.Utils.TileFinder;
import FunctionLibrary.CapableFunc;
import itumulator.executable.DisplayInformation;
import itumulator.world.Location;
import itumulator.world.World;

import java.awt.*;
import java.util.*;
import java.util.List;

public class Bear extends Predator {

    /** The center location of the bear's territory.
     *  The bear will only move around within the territory, except if it findes food just outside its territory.
     * */
    private Location territoryCenter;

    /** The size of the bear's territory, given as a radius from the center location.
     * */
    private int territoryRadius;

    private static final List<String> fightPriority = new ArrayList<>();
    static {
        fightPriority.add("wolf");
        fightPriority.add("bear");
        fightPriority.add("putin");
        //fightPriority.add("beartin");
    }

    private static final EnumMap<CapableEnums.AnimalSize, Double> strengthBonus_AnimalSize = new EnumMap<>(CapableEnums.AnimalSize.class);
    static {
        strengthBonus_AnimalSize.put(CapableEnums.AnimalSize.BABY, 4.0);
        strengthBonus_AnimalSize.put(CapableEnums.AnimalSize.ADULT, 7.0);
    }
    private static final EnumMap<CapableEnums.FungiState, Double> strengthBonus_FungiState = new EnumMap<>(CapableEnums.FungiState.class);
    static {
        strengthBonus_FungiState.put(CapableEnums.FungiState.NORMAL, 0.0);
        strengthBonus_FungiState.put(CapableEnums.FungiState.FUNGI, -2.0);
    }

    /** Defines the map wherein all the display information's are declared. The key is generated by the getDisplayInformationsKey() method */
    protected static final Map<String, DisplayInformation> displayInformations = new HashMap<>();
    static {
        displayInformations.put("Small-Normal-Awake", new DisplayInformation(Color.BLACK, "bear-small"));                   // The display information of a small awake normal bear
        displayInformations.put("Big-Normal-Awake", new DisplayInformation(Color.BLACK, "bear"));                           // The display information of a big awake normal bear

        displayInformations.put("Small-Normal-Sleeping", new DisplayInformation(Color.BLACK, "bear-small-sleeping"));       // The display information of a small sleeping normal bear
        displayInformations.put("Big-Normal-Sleeping", new DisplayInformation(Color.BLACK, "bear-sleeping"));               // The display information of a big sleeping normal bear

        displayInformations.put("Small-Fungi-Awake", new DisplayInformation(Color.BLACK, "bear-fungi-small"));              // The display information of a small awake fungus bear
        displayInformations.put("Big-Fungi-Awake", new DisplayInformation(Color.BLACK, "bear-fungi"));                      // The display information of a big awake fungus bear

        displayInformations.put("Small-Fungi-Sleeping", new DisplayInformation(Color.BLACK, "bear-fungi-small-sleeping"));  // The display information of a small sleeping fungus bear
        displayInformations.put("Big-Fungi-Sleeping", new DisplayInformation(Color.BLACK, "bear-fungi-sleeping"));          // The display information of a big sleeping fungus bear
    }


    /* ----- ----- ----- ----- Constructors ----- ----- ----- ----- */

    public Bear(CapableWorld world) {
        super("bear", world, 40, 0, 35);

        this.territoryCenter = new Location(0, 0);
        this.territoryRadius = 2;


        animalSize = CapableEnums.AnimalSize.BABY;
        animalState = CapableEnums.AnimalState.AWAKE;
        fungiState = CapableEnums.FungiState.NORMAL;
    }

    public Bear(CapableWorld world, Location territoryCenter) {
        super("bear", world, 20, 0, 35);

        this.territoryCenter = territoryCenter;
        this.territoryRadius = 2;

        animalSize = CapableEnums.AnimalSize.BABY;
        animalState = CapableEnums.AnimalState.AWAKE;
        fungiState = CapableEnums.FungiState.NORMAL;
    }

    public Bear(CapableWorld world, int age, int MATING_AGE, int MATING_COOLDOWN_DURATION,  Location territoryCenter) {
        super("bear", world, 20, age, 35, MATING_AGE, MATING_COOLDOWN_DURATION);

        this.territoryCenter = territoryCenter;
        this.territoryRadius = 2;

        animalSize = CapableEnums.AnimalSize.BABY;
        animalState = CapableEnums.AnimalState.AWAKE;
        fungiState = CapableEnums.FungiState.NORMAL;
    }

    /* ----- ----- ----- ----- Behavior ----- ----- ----- ----- */

    @Override
    public void act(World world) {
        super.act(world);
        if (isOnMap){
            if (animalSize.equals(CapableEnums.AnimalSize.ADULT)) {
                if (!(tryMate() || tryFight()))
                    lookForFood(1);
            }
            else
                lookForFood(2);
        }

    }

    @Override
    protected void doEverySimulationStep() {}

    @Override
    protected void attackEnemy(Predator enemy) {

    }

    @Override
    public void move(){
        Set<Location> territory = world.getSurroundingTiles(territoryCenter, territoryRadius- 1);
        Set<Location> neighbours = world.getEmptySurroundingTiles(getLocation());

        List<Location> validNeighbours = new ArrayList<>();
        for (Location neighbour : neighbours) {
            if (PathFinder.distance(getTerritoryCenter(), neighbour) <= territoryRadius) {
                if (world.isTileEmpty(neighbour)) validNeighbours.add(neighbour);
            }

        }
        Location searchLocation;
        if (validNeighbours.isEmpty()) {
            Location nearestLocation = PathFinder.getClosestTile(world, getLocation(), territoryCenter);
            if (nearestLocation == null) return;
            searchLocation = nearestLocation;
        }
        else {
            Random rand = new Random();
            searchLocation = validNeighbours.get(rand.nextInt(validNeighbours.size()));
        }
        world.move(this, searchLocation);
    }
    // TODO make test that test if a bear moves out of it territory.

    @Override
    public void updateOnMap(Location location, boolean isOnMap) {
        super.updateOnMap(location, isOnMap);
        territoryCenter = location;
    }

    /* ----- ----- ----- ----- Fighting ----- ----- ----- ----- */

    @Override
    protected boolean tryFight() {
        List<Predator> enemies = new ArrayList<>();

        Map<String, List<Predator>> enemiesMap = new HashMap<>();
        for (String key : CapableFunc.getAllPredatorTypes())
            enemiesMap.put(key, new ArrayList<>());

        if (!lookForEnemy(enemies, 2)) return false;

        Predator enemy = null;
        for (Predator possibleEnemy : enemies) {
            List<Predator> list = enemiesMap.get(possibleEnemy.actorType);
            list.add(possibleEnemy);
            enemiesMap.put(possibleEnemy.actorType, list);
        }

        for (String key : enemiesMap.keySet()) {
            for (Predator predator : enemiesMap.get(key)) {
                enemy  = predator;
                break;
            }
        }
        if (enemy == null) return false;

        attackEnemy(enemy);
        return false;
    }

    /** Tries to find a mate, and produce an offspring.
     * @return Returns true if a mate is found and a successful reproduction occurs or a mate is found and the bear goes towards it.
     * Otherwise, returns false.
     */
    private boolean tryMate() {
        List<Bear> mates = new ArrayList<>();

        if (!lookForMate(mates, 4)) return false;

        Bear mate = mates.get(new  Random().nextInt(mates.size()));
        Location mateLocation = mate.getLocation();

        if (PathFinder.distance(getLocation(), mateLocation) > 1) {
            moveTowards(mateLocation);
            return true;
        }

        mate(mate);
        return true;
    }



    /** Tries to find mates within a certain area.
     * @param mates is the list wherein the found mates are inserted into.
     * @param radius The radius of the area to search for mates in.
     * @return Returns true if any possible mates were found, otherwise returns false.
     */
    private boolean lookForMate(List<Bear> mates, int radius) {
        Set<Location> neighbors = world.getSurroundingTiles(getLocation(), radius);
        for (Location l : neighbors) {
            Object o = world.getTile(l);
            if (o instanceof Bear bear) {
                if (bear.canMate())
                    mates.add(bear);
            }
        }
        return !mates.isEmpty();
    }

    /** Produces a bear offspring and adds it to the world.
     * @param bear The actor to mate with.
     */
    private void mate(Bear bear) {
        System.out.println("Bear mate");

        TileFinder tileFinder = new TileFinder(world);
        Location offspringLocation = tileFinder.getEmptyTileAroundActor(this, true);
        Location offspringTerritoryLocation = tileFinder.getEmptyTile(world, true);
        if (offspringLocation == null) return;

        // makes new rabbit
        Bear offspring = new Bear(world, offspringLocation);

        // Spawn offspring at location
        SpawningAgent spawningAgent = new SpawningAgent(world);
        spawningAgent.spawnActorAtLocation(offspring,  offspringTerritoryLocation);

        // Updates the relevant mating information.
        animalJustReproduce();
        bear.animalJustReproduce();
    }

    @Override
    protected boolean isAnimalEnemy(Predator possibleEnemy) {
        if (possibleEnemy instanceof Wolf wolf) {
            List<Wolf> nearbyWolfs = new ArrayList<>();
            wolf.getWolfGang().getNearbyWolfsFromGang(wolf,  nearbyWolfs);
            return nearbyWolfs.size() < 3;
        }
        else if (possibleEnemy instanceof Bear){
            return !canMate();
        }
        return false;
    }

    @Override
    public double getStrengthValue() {
        double strength = 0;
        strength += strengthBonus_AnimalSize.get(animalSize);
        strength += strengthBonus_FungiState.get(fungiState);
        return strength;
    }
    /* ----- ----- ----- ----- Events ----- ----- ----- ----- */

    @Override
    public void onDawn() {

    }

    @Override
    public void onNightFall() {

    }

    @Override
    public void onDusk() {

    }

    /* ----- ----- ----- ----- Getters and Setters ----- ----- ----- ----- */

    @Override
    public DisplayInformation getInformation() {

        DisplayInformation returnValue = displayInformations.get(getDisplayInformationsKey());

        return returnValue;
    }

    public Location getTerritoryCenter() { return territoryCenter; }

    public int getTerritoryRadius() { return territoryRadius; }
}
